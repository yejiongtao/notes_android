1. RecyclerView.onScrollListener
	can detect when you are at the end of the results
	and then you can add new results to it

2. dynamically adjust the number of columns of the RecyclerView
	one way to do this is create an integer resource with a orientation qualifier
		Integer resources should be placed in res/values
		but the number of columns are actually hard-coded in this way
	another approach is to calculate the number in your code 
		based on the width of the RecyclerView and a predetermined constant column width
		you cannot calculate the number of columns in onCreateView() because the RecyclerView will not be sized yet
			implement a ViewTreeObserver.OnGlobalLayoutListener
			put your column calculation code in onGlobalLayout()
			Add the listener to your RecyclerView using addOnGlobalLayoutListener().

3. downloading lots of small things
	download them when they need to be displayed on screen
		triggers the downloading in RecyclerView.onBindViewHolder()
	AsyncTask is the easiest way to get a background thread, but it is ill-suited for repetitive and long-running work
		because actually, starting with Android 3.2, it uses an Executor to run all the AsyncTasks on one single background thread
			which means the AsyncTasks will run one after another
	intead, commonly we create a dedicated background thread

4. message loop
	


caching and preloading	--two measures to make your app seem faster
	caching
		room is limited, so you have to decide the strategy to use when room runs out, usually LRU, least recently used
		LruCache is a class in Android support library
	preloading
		once you build a cache, you can preload things into it
		e.g. preload the previous 10 and the next 10 pictures

Picasso	--a third-party library for downloading, caching and transforming images
	simple like this
		Picasso.with(getActivity())
                    .load(galleryItem.getUrl())
                    .placeholder(R.drawable.bill_up_close)
                    .into(mItemImageView);
	








